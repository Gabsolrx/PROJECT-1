-- POSTGRESQL OCTOBER COHORT 2023
-- FACILITATED BY ABDULLAH BANKOLE BANKOLE, MCT MCDAA GMNSE
-- FOR QUANTUM ANALYTICS 

-- SELECT STATEMENT
-- USED TO FETCH COLUMN FROM A TABLE 

-- FETCH ALL COLUMNS 
-- WE USE THE * AFTER THE SELECT STATEMENT TO FETCH ALL THE COLUMNS 

SELECT * FROM ACTOR;

SELECT * FROM STAFF;

SELECT* FROM FILM;

-- FETCH SPECIFIC COLUMNS
-- WE INOUT THE NAMESOF THE DESIRED COLUMN AFTER THE SELECT STATEMNT 

SELECT FIRST_NAME, LAST_NAME FROM ACTOR;

-- SORTING RECORDS 
--THIS IS THE ARRANGEMENT OF RECORDS IN A UNIFORM MANNER 

-- ORDER BY==> USED TO SORT RECORD
-- ASCENDING, ASC ==> FROM THE SMALLES TO THE BIGGEST, A-Z, 0-9
-- DESCENDING, DESC ==> FROM THE BIGGEST TO THE SMALLEST, Z-A,9-0

SELECT FIRST_NAME,LAST_NAME FROM ACTOR
ORDER BY LAST_NAME ASC;

SELECT * FROM PAYMENT
ORDER BY AMOUNT DESC;

-- LIMITING RECORDS
-- REDUCE THE AMOUNT OF ROW OR RECORDS THAT SHOWN
-- LIMIT N ==> USED TO LIMIT RECORDS 
-- N ==> NUMBER OF RECORDS WE WANT TO SHOW

-- TOP10 HIGHEST TRANSACTION
SELECT * FROM PAYMENT 
ORDER BY AMOUNT DESC
LIMIT 10;

-- FILTERING RECORDS 
-- WHERE ==>USED TO FILTER RECRRDS 

-- OPERATORS 
	-- MATHEMATICAL OPERATORS ==> >, <,=, >=,<=
	-- LOGICAL OPERATORS ==> AND, OR 

-- FETCH THE FULL NAME OF THE CUSTOMER(S) WHOSE FIRSTNAME IS 'JAMIE'

SELECT * FROM CUSTOMER;

SELECT FIRST_NAME,LAST_NAME FROM CUSTOMER
WHERE FIRST_NAME = 'Jamie';

-- FETCH THE FULL NAME OF THE CUSTOMER(S) WHOSE FIRSTNAME IS 'JAMIE' and lastname is "rice"
SELECT FIRST_NAME,LAST_NAME FROM CUSTOMER
WHERE FIRST_NAME = 'Jamie' and  last_name = 'Rice';

-- PREDICATES
-- CALLED ADVANCED FILTERS 

-- BETWEEN : FILTER WITHIN A RANGE OF VALUES 

-- WE WANT TO KNOW THE CUSTOMERS WHO HAVE PAID AN AMOUNT BETWEEN 8 AND 10 USD 

SELECT CUSTOMER_ID, AMOUNT FROM PAYMENT
WHERE AMOUNT BETWEEN 8 AND 10;

-- IN: USED TO FILTER MULTIPLE RECORDS IN A COLUMN
-- GGET ALL INFO OF CUSTOMER 361, 362 AND 363

SELECT * FROM CUSTOMER
WHERE CUSTOMER_ID IN (361, 362, 363);

SELECT * FROM CUSTOMER
WHERE first_name IN ( 'Lawrence', 'Nicholas', 'Roy');

-- LIKE: USED FOR PATTERN FILTERING 
-- %: USED TO FILTER AS MANY CHARACTERS AS POSSIBLE 
-- _: USED TO FILTER ONLY ONE CHARACTER AT A TIME 


-- GET THE INFO OF CUSTOMERS WHOSE FIRSTNAME START WITH "Jen"
SELECT * FROM CUSTOMER
WHERE FIRST_NAME LIKE 'Jen%';

-- GET THE INFO OF CUSTOMERS WHOSE FIRSTNAME START WITH "Jen" and have two letter afterwards
SELECT * FROM CUSTOMER
WHERE FIRST_NAME LIKE 'Jen__';


-- get the info of customers whose lastname ENDS with 'is'
select * from customer
where last_name like '%is';

-- GET THE INFO OF CUSTOMERS WHOSE FIRSTNAME START WITH "Jen" and lastnme end with "is"
SELECT * FROM CUSTOMER
WHERE FIRST_NAME LIKE 'Jen%' and Last_name like '%is';


-- AGGREGATES
-- USED TO PERFORM SIMPLE STATICSTICAL OPERATIONS 
-- RETURN A SINGLE VALUE AS RESULT 
-- USED TO PERFORM CALCULATIONS ON A SET OF ROWS 

-- SUM:  USED TO CALCULATE THE SUM OF VALUES IN A COLUMN
-- COUNT: USED TO COUNT THE NO OF ROWS IN A COLUMN
-- MIN: USED TO RETURN THE MINIMUM VALUE IN A COLUMN
-- MAX: USED TO RETUNR THE MAXIMUM VALUE IN A COLUMN
-- AVG: USED TO RETURN THE AVERAGE OF VALUES IN A COLUMN 

SELECT AMOUNT FROM PAYMENT;
-- TOTAL SALES MADE 
SELECT SUM(AMOUNT) FROM PAYMENT;
-- TOTAL TRANSCATIOS
SELECT COUNT(AMOUNT) FROM PAYMENT;
-- AVERAGE SALES
SELECT AVG(AMOUNT) FROM PAYMENT;
-- MINIMUM 
SELECT MIN(AMOUNT) FROM PAYMENT;
-- MAXIMUM 
SELECT MAX(AMOUNT) FROM PAYMENT;

SELECT SUM(AMOUNT), COUNT(AMOUNT), AVG(AMOUNT),  MAX(AMOUNT) FROM PAYMENT

--------------------------------------------------
-- ALIASES
-- AS ==> USED TO RENAME OR ALIAS COLUMNS OR TABLES
SELECT SUM(AMOUNT) AS TOTAL_AMOUNT, COUNT(AMOUNT) AS NO_OF_TRANS, AVG(AMOUNT) AS AVG_AMT FROM PAYMENT;

SELECT LAST_NAME AS SURNAME FROM CUSTOMER;

-- GROUPING RECORDS 
-- GROUP BY ==> KEYWORD USED FOR GROUPING RECORDS 
SELECT* FROM PAYMENT;

SELECT CUSTOMER_ID,AMOUNT FROM PAYMENT;

--TOTAL AMOUNT SPENT BY EACH CUSTOMER
SELECT CUSTOMER_ID, SUM(AMOUNT) FROM PAYMENT
GROUP BY CUSTOMER_ID;

-- HOW MANY TIMES EACH CUSTOMER TRANSACTED
SELECT CUSTOMER_ID, COUNT(AMOUNT) FROM PAYMENT
GROUP BY CUSTOMER_ID;

-- FILTERING GROUPED RECORDS 
-- HAVING ==> USED TO FILTER GROUPED RECORDS 
-- HAVING WORKS JUST LIKE THE WHERE KEYWORD
-- IT WORKS WITH OPERATORS (>,<, =, AND,OR) AND PREDICATES (IN, BETWEEN, LIKE)
-- HAVING IS ALWAYS AFTER THE GROUP BY STATEMENT

-- WE WANT TO KNOW THE CUSTOMERS WHO HAVE SPENT BETWEEN USD100 AND USD150
SELECT CUSTOMER_ID, SUM(AMOUNT) FROM PAYMENT
GROUP BY CUSTOMER_ID
HAVING SUM(AMOUNT) BETWEEN 100 AND 150;

SELECT CUSTOMER_ID, SUM(AMOUNT) FROM PAYMENT
GROUP BY CUSTOMER_ID
HAVING SUM(AMOUNT) BETWEEN 100 AND 150
ORDER BY SUM(AMOUNT)ASC;

-- JOINS 
-- USED TO MERGE TWO OR MORE TABLES TOGETHER
-- DONE BASED ON THE RELATIONSHIP BETWEEN THE TWO TABLES

-- HOW TO JOIN 
-- 1. IDENTIFY THE TABLES YOU WOULD BE JOINING
-- 2. IDENTIFY THE COLUMNS THAT YOU NEED FROM EACH TABLE
-- 3. IDENTIFY THE RELATIONSHIP BETWEEN THE TWO TABLES 
-- 4. PUT ALL THE COLUMNS NEEDED INTO A SINGLE SELECT STATEMENT 
-- 5. ADD THE FIRST TABLE AFTER THE FROM, WHICH TAKES THAT TABLE THE TABLE ON THE LEFT SIDE
-- 6. STATE THE JOIN TYPE
-- 7. ADD THE SECOND TABLE AFTER THE JOIN TYPE, WHICH BECOMES THE TABLE ON THE RIGHT SIDE  
-- 8. ADD THE RELATIONSHIP COLUMNS USING THE 'ON' KEYWORD 
	-- ON TABLE1.RELATIONSHIP = TABLE2.RELATIONSHIP 
-- 9. TO PREVENT AMBIGOUS COLUMNS, USE THE TABLE.COLUMNNAME NAMING SYNTAX FOR THE AMBIGIOUS COLUMN

-- INNER JOIN
-- LETS GET THE NAMES OF OUR PAYING CUSTOMERS
SELECT * FROM CUSTOMER;
--CUSTOMER_ID, FIRST_NAME,LAST_NAME 

SELECT* FROM PAYMENT ;
--CUSTOMER_ID,AMOUNT,PAYMENT_DATE

-- RELATIONSHIP: CUSTOMER_ID

SELECT CUSTOMER.CUSTOMER_ID, FIRST_NAME,LAST_NAME, PAYMENT.CUSTOMER_ID,AMOUNT,PAYMENT_DATE
FROM CUSTOMER
INNER JOIN PAYMENT
ON CUSTOMER.CUSTOMER_ID = PAYMENT.CUSTOMER_ID

SELECT CUSTOMER.CUSTOMER_ID, FIRST_NAME,LAST_NAME, AMOUNT,PAYMENT_DATE
FROM CUSTOMER
INNER JOIN PAYMENT
ON CUSTOMER.CUSTOMER_ID = PAYMENT.CUSTOMER_ID
--- LEFTJOIN 
--LET US CONFIRM IF ALLL OUR FILMS ARE IN THE INVENTORY 

SELECT* FROM FILM;
-- FILLM_ID,TITLE

SELECT * FROM INVENTORY;
-- INVENTORY_ID, FILM_ID

-- RELATIONSHIP:FILM_ID

SELECT FILM.FILM_ID,TITLE,INVENTORY_ID, INVENTORY.FILM_ID
FROM FILM
LEFT JOIN INVENTORY
ON FILM.FILM_ID = INVENTORY.FILM_ID


SELECT FILM.FILM_ID,TITLE,INVENTORY_ID
FROM FILM
LEFT JOIN INVENTORY
ON FILM.FILM_ID = INVENTORY.FILM_ID

-- CREATING TABLES 

-- STEPS TO FOLLOW 
-- WE USE THE KEYWORD ==> CREATE TABLE TABLENAME()
-- WITHIN THE BRACKET WE ADD THE COLUMNS FOR THE NEW TABLE
-- WE SPECIFY THE DATATYPES OF THE COLUMNS (VARCHAR, CHAR, INT ETC)
	--DATATYPES: TYPESOF DATA WE WANT IN THE COLUMN 
		-- NUMBER ==> INT(1,2,3,4),FLOAT(3.14, 9.8)
		-- CHARACTERS ===> VARIABLE LENGTH VARCHAR(N), FIXED LENGTH CHAR(N)
		-- DATE ==> DATE, DATETIME
-- WE SPECIFY THE CONSTRAINTS (NOT NULL, UNIQUE, PRIMARY KEY)
	-- CONSTRAINTS ARE RULES GUIDNG A COLUMN 
		-- NOT NULL: THIS COLUMN MUST NOT ACCEPT NULL VLAUES 
		-- UNIQUE: ALL THE ROWS IN THIS COLUMN MUST BE UNIQUE 
		-- PRIMARY KEY : NOT NULL + UNIQUE
 CREATE TABLE OCT_COHORT_2023 (
  	STUDENT_ID INT PRIMARY KEY,
	NAME VARCHAR(20) NOT NULL,
	GENDER CHAR(1) NOT NULL,
	LOCATION  VARCHAR(20) NOT NULL
 );

SELECT * FROM OCT_COHORT_2023;

-- INSERTING RECORDS INTO TABLES 

-- KEYWORD==> INSERT INTO TABLENAME()
-- STATE THE COLUMNS INSIDE THE BRACKET 
-- ADD THE KEYWORD --> VALUES()
-- INSERT THE DATA IN BRACKETS 


INSERT INTO OCT_COHORT_2023
	(STUDENT_ID, NAME, GENDER, LOCATION)
VALUES
	(1, 'FAITH EZEDEBEGO', 'F', 'ASABA'), 
	(2, 'AHMED KOLA ALABI', 'M', 'ISOLO'),
	(3, 'JOSEPH OKORE', 'M', 'ABEOKUTA'), 
	(4, 'ANGELA EBERE', 'F', 'ABUJA'), 
	(5, 'AKPAOKO DARAMFON', 'M', 'LEKKI');
	
SELECT * FROM OCT_COHORT_2023;
------------------------
-- MISCELLANOUES
-- PRACTICE! PRACTICE!! PRACTICE!!!
-- DO YOUR ASSIGNMENT
-- LEARN MORE ==> SQLSHACK, W3SCHOOLS, YOUTUBE

-- CONNECT WITH ME ON LINKDIN: ABDULLAH BANKOLE,  MCDAA GMNSE
-- https://www.linkedin.com/in/abdullahbankole/

-- THE END